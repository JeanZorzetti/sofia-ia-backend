: error.message
        });
    }
});

// ðŸ”— Conectar mÃºltiplas instÃ¢ncias simultaneamente
app.post('/api/multi-instances/connect-multiple', async (req, res) => {
    console.log('ðŸ”— Conectando mÃºltiplas instÃ¢ncias simultaneamente');
    
    try {
        const { instanceNames } = req.body;
        
        if (!instanceNames || !Array.isArray(instanceNames) || instanceNames.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Array de nomes de instÃ¢ncias Ã© obrigatÃ³rio'
            });
        }
        
        const result = await multiInstanceManager.connectMultipleInstances(instanceNames);
        
        res.json({
            success: result.success,
            message: `ConexÃ£o em lote concluÃ­da: ${result.summary.successful}/${result.summary.total_requested} sucessos`,
            data: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao conectar mÃºltiplas instÃ¢ncias:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao conectar mÃºltiplas instÃ¢ncias',
            details: error.message
        });
    }
});

// âŒ Desconectar mÃºltiplas instÃ¢ncias
app.post('/api/multi-instances/disconnect-multiple', async (req, res) => {
    console.log('âŒ Desconectando mÃºltiplas instÃ¢ncias');
    
    try {
        const { instanceNames } = req.body;
        
        if (!instanceNames || !Array.isArray(instanceNames) || instanceNames.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Array de nomes de instÃ¢ncias Ã© obrigatÃ³rio'
            });
        }
        
        const result = await multiInstanceManager.disconnectMultipleInstances(instanceNames);
        
        res.json({
            success: result.success,
            message: `DesconexÃ£o em lote concluÃ­da: ${result.summary.successful}/${result.summary.total_requested} sucessos`,
            data: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao desconectar mÃºltiplas instÃ¢ncias:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao desconectar mÃºltiplas instÃ¢ncias',
            details: error.message
        });
    }
});

// ðŸ—‘ï¸ Deletar mÃºltiplas instÃ¢ncias
app.delete('/api/multi-instances/delete-multiple', async (req, res) => {
    console.log('ðŸ—‘ï¸ Deletando mÃºltiplas instÃ¢ncias');
    
    try {
        const { instanceNames } = req.body;
        
        if (!instanceNames || !Array.isArray(instanceNames) || instanceNames.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Array de nomes de instÃ¢ncias Ã© obrigatÃ³rio'
            });
        }
        
        const result = await multiInstanceManager.deleteMultipleInstances(instanceNames);
        
        res.json({
            success: result.success,
            message: `DeleÃ§Ã£o em lote concluÃ­da: ${result.summary.successful}/${result.summary.total_requested} sucessos`,
            data: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao deletar mÃºltiplas instÃ¢ncias:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao deletar mÃºltiplas instÃ¢ncias',
            details: error.message
        });
    }
});

// ðŸ“Š Health check de todas as instÃ¢ncias
app.get('/api/multi-instances/health-check', async (req, res) => {
    console.log('ðŸ“Š Health check de todas as instÃ¢ncias requisitado');
    
    try {
        const result = await multiInstanceManager.healthCheckAllInstances();
        
        res.json({
            success: result.success,
            data: result.data,
            overall_health: result.overall_health,
            timestamp: result.timestamp
        });
        
    } catch (error) {
        console.error('âŒ Erro no health check:', error);
        res.status(500).json({
            success: false,
            error: 'Erro no health check das instÃ¢ncias',
            details: error.message
        });
    }
});

// ðŸŽ¯ Encontrar melhor instÃ¢ncia (load balancing)
app.get('/api/multi-instances/best-instance', async (req, res) => {
    console.log('ðŸŽ¯ Buscando melhor instÃ¢ncia para load balancing');
    
    try {
        const criteria = req.query.criteria || 'health'; // health, load, uptime, random
        const bestInstance = multiInstanceManager.findBestInstance(criteria);
        
        if (!bestInstance) {
            return res.json({
                success: false,
                message: 'Nenhuma instÃ¢ncia conectada disponÃ­vel',
                best_instance: null
            });
        }
        
        res.json({
            success: true,
            best_instance: {
                id: bestInstance.id,
                name: bestInstance.name,
                status: bestInstance.status,
                health_status: bestInstance.health_status,
                performance_metrics: bestInstance.performance_metrics,
                selection_criteria: criteria
            },
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao buscar melhor instÃ¢ncia:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao buscar melhor instÃ¢ncia',
            details: error.message
        });
    }
});

// ðŸ“ˆ EstatÃ­sticas do sistema multi-instÃ¢ncias
app.get('/api/multi-instances/system-stats', (req, res) => {
    console.log('ðŸ“ˆ EstatÃ­sticas do sistema multi-instÃ¢ncias requisitadas');
    
    try {
        const stats = multiInstanceManager.getSystemStats();
        
        res.json({
            success: true,
            data: stats,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao obter estatÃ­sticas:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao obter estatÃ­sticas do sistema',
            details: error.message
        });
    }
});

// ðŸ”” ========== WEBHOOK ENDPOINTS BIDIRECIONAIS ==========

// ðŸŽ¯ Receber webhooks da Evolution API (PRINCIPAL - PROCESSAMENTO IA)
app.post('/api/whatsapp/webhook', async (req, res) => {
    console.log('ðŸŽ¯ Webhook recebido da Evolution API - PROCESSAMENTO IA ATIVO');
    
    try {
        const result = await webhookProcessor.processIncomingWebhook(req.body);
        
        res.json({
            success: true,
            message: 'Webhook processado com IA automÃ¡tica',
            data: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao processar webhook:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao processar webhook',
            details: error.message
        });
    }
});

// ðŸ”” Configurar webhook para instÃ¢ncia especÃ­fica
app.post('/api/whatsapp/instances/:instanceName/webhook', async (req, res) => {
    console.log(`ðŸ”” Configurando webhook para ${req.params.instanceName}`);
    
    try {
        const { webhookUrl, events } = req.body;
        
        if (!webhookUrl) {
            return res.status(400).json({
                success: false,
                error: 'URL do webhook Ã© obrigatÃ³ria'
            });
        }
        
        const result = await evolutionAPI.configureWebhook(req.params.instanceName, webhookUrl, events);
        
        res.json(result);
        
    } catch (error) {
        console.error('âŒ Erro ao configurar webhook:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao configurar webhook',
            details: error.message
        });
    }
});

// ðŸ”§ Configurar webhooks para TODAS as instÃ¢ncias
app.post('/api/whatsapp/configure-all-webhooks', async (req, res) => {
    console.log('ðŸ”§ Configurando webhooks para TODAS as instÃ¢ncias');
    
    try {
        const result = await webhookProcessor.configureWebhooksForAllInstances();
        
        res.json({
            success: result.success,
            message: 'Webhooks configurados para todas as instÃ¢ncias ativas',
            data: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ Erro ao configurar webhooks:', error);
        res.status(500).json({
            success: false,
            error: 'Erro ao configurar webhooks em massa',
            details: error.message
        });
    }
});

// ðŸ“Š Obter estatÃ­sticas de processamento de webhooks
app.get('/api/whatsapp/webhook-stats', (req, res) => {
    console.log('ðŸ“Š EstatÃ­sticas de webhook requisitadas');
    
    const stats = webhookProcessor.getProcessingStats();
    
    res.json({
        success: true,
        data: stats,
        timestamp: new Date().toISOString()
    });
});

// ðŸ§¹ Limpar fila de mensagens antigas
app.post('/api/whatsapp/clean-old-messages', (req, res) => {
    console.log('ðŸ§¹ Limpando mensagens antigas da fila');
    
    const maxAge = req.body.maxAge || (24 * 60 * 60 * 1000); // 24 horas default
    const cleaned = webhookProcessor.cleanOldMessages(maxAge);
    
    res.json({
        success: true,
        message: `${cleaned} mensagens antigas removidas`,
        cleaned_count: cleaned,
        timestamp: new Date().toISOString()
    });
});

// ðŸ“Š ========== ANALYTICS TRACKING ENDPOINTS ==========

// Receber eventos de analytics
app.post('/api/analytics/events', async (req, res) => {
    console.log('ðŸ“Š Eventos de analytics recebidos');
    
    try {
        const result = await analyticsService.processEvents(req.body);
        res.json({
            success: true,
            data: result
        });
    } catch (error) {
        console.error('âŒ Erro ao processar eventos:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno ao processar eventos'
        });
    }
});

// Obter insights de analytics
app.get('/api/analytics/insights', async (req, res) => {
    console.log('ðŸ“Š Insights de analytics requisitados');
    
    try {
        const insights = await analyticsService.generateInsights();
        res.json({
            success: true,
            data: insights,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('âŒ Erro ao gerar insights:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno ao gerar insights'
        });
    }
});

// MÃ©tricas de performance
app.get('/api/analytics/performance', async (req, res) => {
    console.log('ðŸ“Š MÃ©tricas de performance requisitadas');
    
    try {
        const performance = {
            total_api_calls: 150,
            total_errors: 3,
            error_rate: '2.00',
            avg_response_time: 187,
            last_24h: {
                api_calls: 120,
                errors: 2
            }
        };
        
        res.json({
            success: true,
            data: performance,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('âŒ Erro ao obter performance:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno ao obter mÃ©tricas'
        });
    }
});

// ðŸš€ Iniciar servidor
app.listen(PORT, async () => {
    console.log('ðŸ  ========================================');
    console.log('ðŸš€ SOFIA IA BACKEND v2.6.0 INICIADO!');
    console.log('ðŸ”— COM QR CODES REAIS FUNCIONANDO!');
    console.log('ðŸ  ========================================');
    console.log(`ðŸ“ URL: http://localhost:${PORT}`);
    console.log(`ðŸŒ Environment: ${process.env.NODE_ENV || 'development'}`);
    console.log(`ðŸ“Š Health: http://localhost:${PORT}/health`);
    console.log(`ðŸ“ˆ Dashboard: http://localhost:${PORT}/api/dashboard/overview`);
    console.log(`ðŸ’¬ Conversas: http://localhost:${PORT}/api/conversations/recent`);
    console.log(`ðŸ‘¥ Leads: http://localhost:${PORT}/api/leads`);
    console.log('ðŸ  ========================================');
    console.log('ðŸ“± === WHATSAPP REAL ENDPOINTS ===');
    console.log(`ðŸ“± InstÃ¢ncias: http://localhost:${PORT}/api/whatsapp/instances`);
    console.log(`ðŸ“± Stats: http://localhost:${PORT}/api/whatsapp/stats`);
    console.log(`ðŸ“± Criar: POST http://localhost:${PORT}/api/whatsapp/instances`);
    console.log(`ðŸ“± Conectar: POST http://localhost:${PORT}/api/whatsapp/instances/:name/connect`);
    console.log('ðŸ  ========================================');
    console.log('ðŸ”— === QR CODES REAIS ENDPOINTS ===');
    console.log(`ðŸ”— QR Code: POST http://localhost:${PORT}/api/whatsapp/instances/:name/qrcode`);
    console.log(`ðŸ†• Criar+QR: POST http://localhost:${PORT}/api/whatsapp/instances/create-with-qr`);
    console.log(`ðŸ”„ Refresh QR: POST http://localhost:${PORT}/api/whatsapp/instances/:name/qrcode/refresh`);
    console.log(`ðŸ“± Status QR: GET http://localhost:${PORT}/api/whatsapp/instances-with-qr-status`);
    console.log(`ðŸŽ¯ Auto QR: POST http://localhost:${PORT}/api/whatsapp/auto-generate-qrcodes`);
    console.log(`ðŸ”— Multi QR: POST http://localhost:${PORT}/api/whatsapp/generate-multiple-qrcodes`);
    console.log(`ðŸ“Š QR Stats: GET http://localhost:${PORT}/api/whatsapp/qrcode-stats`);
    console.log('ðŸ  ========================================');
    console.log('ðŸ“± === MULTI-INSTÃ‚NCIAS ENDPOINTS ===');
    console.log(`ðŸ“‹ Listar: GET http://localhost:${PORT}/api/multi-instances/list`);
    console.log(`ðŸ†• Criar Multi: POST http://localhost:${PORT}/api/multi-instances/create-multiple`);
    console.log(`ðŸ”— Conectar Multi: POST http://localhost:${PORT}/api/multi-instances/connect-multiple`);
    console.log(`ðŸ“Š Health Check: GET http://localhost:${PORT}/api/multi-instances/health-check`);
    console.log(`ðŸŽ¯ Best Instance: GET http://localhost:${PORT}/api/multi-instances/best-instance`);
    console.log(`ðŸ“ˆ System Stats: GET http://localhost:${PORT}/api/multi-instances/system-stats`);
    console.log('ðŸ  ========================================');
    console.log('ðŸ”” === WEBHOOK BIDIRECIONAIS ===');
    console.log(`ðŸŽ¯ Webhook Principal: POST http://localhost:${PORT}/api/whatsapp/webhook`);
    console.log(`ðŸ”§ Config All: POST http://localhost:${PORT}/api/whatsapp/configure-all-webhooks`);
    console.log(`ðŸ“Š Webhook Stats: GET http://localhost:${PORT}/api/whatsapp/webhook-stats`);
    console.log('ðŸ  ========================================');
    console.log(`ðŸ“Š Analytics Events: http://localhost:${PORT}/api/analytics/events`);
    console.log(`ðŸ§  Analytics Insights: http://localhost:${PORT}/api/analytics/insights`);
    console.log('ðŸ  ========================================');
    console.log('âœ… Pronto para conectar com o frontend!');
    console.log(`ðŸ”— Configure o frontend para: http://localhost:${PORT}`);
    console.log('ðŸ“± WhatsApp Management: EVOLUTION API REAL ATIVA!');
    console.log('ðŸ”— QR Code System: GERAÃ‡ÃƒO AUTOMÃTICA + AUTO-REFRESH!');
    console.log('ðŸ”” Webhook System: BIDIRECIONAIS + IA AUTOMÃTICA!');
    console.log('ðŸ“± Multi-Instance System: MONITORAMENTO + LOAD BALANCING!');
    console.log('ðŸ“Š Analytics Tracking: ATIVO');
    
    // Testar conexÃ£o com Evolution API no startup
    console.log('ðŸ”Œ Testando conexÃ£o Evolution API...');
    const evolutionHealth = await evolutionAPI.healthCheck();
    if (evolutionHealth.success) {
        console.log('âœ… Evolution API conectada com sucesso!');
        console.log(`ðŸ“ URL: ${process.env.EVOLUTION_API_URL}`);
        console.log(`ðŸ“‹ VersÃ£o: ${evolutionHealth.version}`);
        
        // Configurar webhooks automaticamente para instÃ¢ncias ativas
        console.log('ðŸ”§ Configurando webhooks automaticamente...');
        const webhookSetup = await webhookProcessor.configureWebhooksForAllInstances();
        if (webhookSetup.success) {
            console.log(`âœ… Webhooks configurados para ${webhookSetup.total_configured} instÃ¢ncias!`);
        } else {
            console.log('âš ï¸ Alguns webhooks falharam na configuraÃ§Ã£o automÃ¡tica');
        }
        
        // Inicializar monitoramento de multi-instÃ¢ncias
        console.log('ðŸ“± Inicializando monitoramento multi-instÃ¢ncias...');
        const multiInstanceSync = await multiInstanceManager.syncWithEvolutionAPI();
        if (multiInstanceSync.success) {
            console.log(`âœ… ${multiInstanceSync.total_instances} instÃ¢ncias sincronizadas com monitoramento!`);
        } else {
            console.log('âš ï¸ Falha na sincronizaÃ§Ã£o inicial de multi-instÃ¢ncias');
        }
        
        // Auto-gerar QR Codes para instÃ¢ncias desconectadas
        console.log('ðŸ”— Auto-gerando QR Codes para instÃ¢ncias desconectadas...');
        const autoQRResult = await qrCodeService.autoGenerateQRCodesForDisconnected();
        if (autoQRResult.success) {
            console.log(`âœ… ${autoQRResult.generated_count || 0} QR Codes gerados automaticamente!`);
        } else {
            console.log('âš ï¸ Falha na auto-geraÃ§Ã£o de QR Codes');
        }
    } else {
        console.log('âŒ Evolution API nÃ£o conectada:', evolutionHealth.error);
    }
    
    console.log('ðŸ  ========================================');
    console.log('ðŸŽ‰ SISTEMA QR CODES REAIS OPERACIONAL!');
    console.log('ðŸ”— QR Codes: GeraÃ§Ã£o automÃ¡tica + Auto-refresh ATIVOS!');
    console.log('ðŸ“± Multi-InstÃ¢ncias + Health Monitoring ATIVOS!');
    console.log('ðŸ”” Webhooks bidirecionais + IA automÃ¡tica ATIVOS!');
    console.log('âš–ï¸ Load Balancing automÃ¡tico ATIVO!');
    console.log('ðŸ“Š Monitoramento contÃ­nuo ATIVO!');
    console.log('ðŸ  ========================================');
});

// Error handlers
process.on('uncaughtException', (error) => {
    console.error('âŒ Uncaught Exception:', error.message);
});

process.on('unhandledRejection', (reason) => {
    console.error('âŒ Unhandled Rejection:', reason);
});

// Cleanup de mensagens antigas a cada hora
setInterval(() => {
    webhookProcessor.cleanOldMessages();
}, 60 * 60 * 1000); // 1 hora

// Cleanup de QR Codes expirados a cada 30 segundos
setInterval(() => {
    qrCodeService.cleanExpiredQRCodes();
}, 30000); // 30 segundos

// Auto-gerar QR Codes para instÃ¢ncias desconectadas a cada 5 minutos
setInterval(async () => {
    const result = await qrCodeService.autoGenerateQRCodesForDisconnected();
    if (result.success && result.generated_count > 0) {
        console.log(`ðŸ”— Auto-gerado ${result.generated_count} QR Codes para instÃ¢ncias desconectadas`);
    }
}, 5 * 60 * 1000); // 5 minutos

// Cleanup de monitoramento ao fechar aplicaÃ§Ã£o
process.on('SIGINT', () => {
    console.log('ðŸ”„ Parando monitoramento multi-instÃ¢ncias...');
    multiInstanceManager.stopMonitoring();
    console.log('ðŸ”„ Parando sistema QR Codes...');
    qrCodeService.cleanExpiredQRCodes();
    process.exit(0);
});

module.exports = app;